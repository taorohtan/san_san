//---------------------------------------------------------------------// ----------------タッチイベントが利用可能かの判別-------------------------var supportTouch = 'ontouchend' in document;// イベント名var E_TOUCHSTART = supportTouch ? 'touchstart' : 'mousedown';var E_TOUCHMOVE = supportTouch ? 'touchmove' : 'mousemove';var E_TOUCHEND = supportTouch ? 'touchend' : 'mouseup';//=====================================================================//==========function draw(id) {    var canvas = document.getElementById(id);    if (canvas == null)    	return false;		var context = canvas.getContext('2d');//==========var mx;var my;var stX;var edX;var c=0;//---問題数カウントvar num;//ten_key入力の値var kkm;var mon;//入力された個数	mon=0;var pp=[];//---入力文字配列var mm=[];mm[0]="0";mm[1]="1";mm[2]="2";mm[3]="3";mm[4]="4";mm[5]="5";mm[6]="6";mm[7]="7";mm[8]="8";mm[9]="9";mm[16]="＜";mm[17]="";mm[18]="＞";mm[19]="°"var kotae;var kotae0;var bmoji;var kosu=[];//---〜のいくつ分const pinp = new Audio('pinpon.mp3');const bu = new Audio("bubu.mp3");var a//var a=20var b//var b=160var d=180var cx=250var cy=200var dh=160var bdjj=1var hint=1var zero=0bmoji=String(b)bgcolor();ten_key();//kkd(a,b,d,cx,cy);//b_doki(zero);kotae0=bfunction main(){	bgcolor();	//ten_key();	ten_key_basyo();		kkd(a,b,d,cx,cy);	if(bdjj==0){b_doki(zero);}else{}		nyuryoku();	select();	fig();	context.fillStyle = 'blue';	context.font = "20px Arial";	if(c!=0){context.fillText("（"+c+"）",5, 35);}else{}		ten_key();//---分度器より前面に表示するための位置}function kkd(a, b, d, cx, cy){	//----- a:開始角　b:表示角　d:半径　cx,cy: 中心座標	//------a+b が終点角になる	var a; var b; var d; var cx; var cy;	var x1; var x2; var y1; var y2;		x1 = d*Math.cos(a * (Math.PI/180));	y1 = d*Math.sin(a * (Math.PI/180));	x2 = d*Math.cos((a+b) * (Math.PI/180));	y2 = d*Math.sin((a+b) * (Math.PI/180));	context.beginPath();	context.strokeStyle='rgba(0,0,255,1)';	context.moveTo(cx + x1, cy - y1);	context.lineTo(cx, cy);	if(y2<-80){context.lineTo((cx + x2*0.3), (cy - y2*0.3));}else{context.lineTo(cx + x2, cy - y2);}	context.stroke();	context.closePath();		context.beginPath();	context.fillStyle='rgba(0,255,0,0.5)';	context.moveTo(cx,cy);	context.arc(cx, cy, 30, -a/180*Math.PI, -(a+b)/180*Math.PI, true);	context.fill();	context.closePath();		if(b>180 && hint==0){		context.beginPath();		context.strokeStyle='rgba(255,0,0,0.8)';		//context.moveTo(cx + x2, cy - y2);		context.lineTo(cx, cy);		context.lineTo(cx - x2, cy + y2);		context.stroke();		context.closePath();	}	console.log("x2= "+x2+" : y2= "+y2)}function b_doki(t){	var i; var j; var t; var k=0;	for (i=0+t; i<=180+t; i++){		if (k%5==0){if(k%10==0){j=-dh*0.64}else{j=-dh*0.03}}else{j=0}		if (i==90+t){j=-dh*0.92}		if (k%10==0){			if(i==90+t){			context.fillStyle = 'red';			context.font = "16px Arial";			context.fillText(90,lox(dh*0.8,i)+cx-dh*0.05,cy-loy(dh*0.8,i)+dh*0.05)			}else{			context.fillStyle = 'black';			context.font = "10px Arial";			context.fillText(180-i+t,lox(dh*0.82,i)+cx-dh*0.03,cy-loy(dh*0.82,i))			context.fillStyle = 'red';			context.font = "9px Arial";			context.fillText(i-t,lox(dh*0.72,i)+cx-dh*0.03,cy-loy(dh*0.72,i))			}		}		kaku(lox(dh,i),loy(dh,i),lox(dh*0.92+j,i),loy(dh*0.92+j,i),cx,cy)				if(i==180+t){			context.beginPath();			context.strokeStyle='rgba(0,0,255,0.5)';			context.arc(cx, cy, dh*0.78, -(95+t)/180*Math.PI, -(180+t)/180*Math.PI, true);			context.arc(cx, cy, dh*0.68, -t/180*Math.PI, -(180+t)/180*Math.PI, true);			context.arc(cx, cy, dh*0.44, -t/180*Math.PI, -(180+t)/180*Math.PI, true);			context.arc(cx, cy, dh*0.28, -t/180*Math.PI, -(180+t)/180*Math.PI, true);			context.stroke();			context.beginPath();//90をはさんだ半円--弦を結んでしまうので別個に記述			context.strokeStyle='rgba(0,0,255,0.5)';			context.arc(cx, cy, dh*0.78, -t/180*Math.PI, -(85+t)/180*Math.PI, true);			context.stroke();		}		k++;	}}function kaku(x1,y1,x2,y2,cx,cy){	var x1; var y1; var x2; var y2; var cx; var cy;		context.lineWidth = 1	context.beginPath();	context.strokeStyle='rgba(0,0,255,0.5)';	context.moveTo(x1 + cx, cy - y1);	context.lineTo(x2 + cx, cy - y2);	context.stroke();	context.closePath();	}function lox(d,a){	var d; var a; var x;	x = d*Math.cos(a * (Math.PI/180));	return x;}function loy(d,a){	var d; var a; var y;	y = d*Math.sin(a * (Math.PI/180));	return y;}//-----数値入力function nyuryoku(){		//var h;var t; var o;		if((mx>184 && mx<410) && (my>260 && my<320)||(mx>410 && mx<450)&&(my>230 && my<260)){			pp[mon]=mm[num];			//if (mon<3){mon++;}//---3桁まで入力			if (mon<bmoji.length + 1){mon++;}//---文字数分まで入力		}		//context.fillText(num,54+s1*20,250);}//-----数値入力表示function fig(){		var s1;		context.fillStyle = 'red';		context.font = "28px Arial";		for (s1=0; s1<mon; s1++){		context.fillText(pp[s1],360+s1*30,40);//175-----ansx+s1*13,ansy);//---13は字間		}		context.strokeStyle = "blue";		context.strokeRect(340,14,126,32);}//-----　← M A N 押下時の処理function select(){	var i;	if((mx>405 && mx<500) && (my>260 && my<320)){		if(num==12){					hint=1			kotae=0;			mon=0;			bgcolor();			ten_key();			zero=Math.floor(Math.random() * 19) + 1 ;			a=Math.floor(Math.random() * 19) + 1 			b=Math.floor(Math.random() * 359) + 1 ;			kotae0=b			kkd(a, b, d, cx, cy)			bdjj=1			c=c+1		}				if(num==11){if(mon>0){mon=mon-1;}}		if(num==13){			//rline();			mon=mon-1;			kotae="";				for (i=0; i<mon+1; i++){				kotae=kotae+pp[i];				}			if(String(kotae0)+"°" == String(kotae)){				pinbu(0,0.5);				mon=mon+1;				context.fillStyle = 'red';				context.font = "96px Arial";				context.fillText("◯", 388,128);			}else{mon=0;pinbu(1,0.5);}		}		if(num==14){//-----次の問題			bgcolor();			ten_key();			mon=0;			c=0;		}	}}//-----テンキー表示function ten_key(){		var i; var j;				context.fillStyle='#afeeee';		for(i=0; i<7; i++){			for(j=0; j<2; j++){				context.fillStyle='#afeeee'				fillRoundRect(context,　184+i*45,260+j*30, 43, 28, 5);				if (i<5){					context.fillStyle = 'blue';					context.font = "24px Arial";					if(j==0){context.fillText(i+1,194+4+i*45,24+260+j*28);}						else{if(i==4){context.fillText(i-4,194+4+i*45,24+260+j*28);}						else{context.fillText(i+6,194+4+i*45,24+260+j*28);}}					} else {}			}		}				fillRoundRect(context,　184+5*45,230, 43, 28, 5);		fillRoundRect(context,　184+6*45,230, 43, 28, 5);				context.fillStyle = 'blue';		context.font = "20px Arial";		context.fillText("←",194+5*45,24+260);		context.fillText("問",194+6*45,24+260);		context.fillText("答",194+5*45,24+260+28);		context.font = "14px Arial";		context.fillText("（1）",185+6*45,24+260+28);		context.fillText("°",194+5*45,250)		context.fillText(" Ｈ",194+6*45,250);				//---分度器操作		for(i=1; i<4; i++){		j=1;		context.fillStyle='#ffcc99'// 'rgba(0, 255, 0, 0.3)'//'#afeeee'		fillRoundRect(context,　4+i*45,260+j*30, 43, 28, 5);		context.fillStyle = 'blue';		context.font = "18px Arial";		context.fillText(mm[i+15],8+8+i*45,24+260+j*28);		}				context.beginPath();		context.arc(116,275, 8, -0/180*Math.PI, -360/180*Math.PI, true);		context.fillStyle='#ff6699'//'rgba(255,0,0,0.3)';		context.fill();				context.beginPath();		context.moveTo(106,268);		context.lineTo(106,282);		context.lineTo(49,275);		context.closePath();		context.fillStyle='#ffcc99'//'rgba(0,255,0,0.3)';		context.fill();		context.beginPath();		context.moveTo(126,268);		context.lineTo(126,282);		context.lineTo(183,275);		context.closePath();		context.fillStyle='#ffcc99'//'rgba(0,255,0,0.3)';		context.fill();		context.beginPath();		//---分度器ボタン↓		context.beginPath();		context.strokeStyle='rgba(0,0,0,1)';		context.moveTo(116,312);		context.arc(116, 312, 12, Math.PI, 0, false);		context.closePath();		context.stroke();}//-----テンキー押下時の値取得function ten_key_basyo(){	rline();//点線丸囲いが描かれてしまうので入れておく		if((mx>184 && mx<229) && (my>260 && my<290)){num=1;}	if((mx>229 && mx<274) && (my>260 && my<290)){num=2;}	if((mx>274 && mx<319) && (my>260 && my<290)){num=3;}	if((mx>319 && mx<360) && (my>260 && my<290)){num=4;}	if((mx>360 && mx<405) && (my>260 && my<290)){num=5;}		if((mx>405 && mx<450) && (my>260 && my<290)){num=11;}	if((mx>450 && mx<495) && (my>260 && my<290)){num=12;}		if((mx>184 && mx<229) && (my>290 && my<320)){num=6;}	if((mx>229 && mx<274) && (my>290 && my<320)){num=7;}	if((mx>274 && mx<319) && (my>290 && my<320)){num=8;}	if((mx>319 && mx<360) && (my>290 && my<320)){num=9;}	if((mx>360 && mx<405) && (my>290 && my<320)){num=0;}		if((mx>405 && mx<450) && (my>290 && my<320)){num=13;}	if((mx>450 && mx<495) && (my>290 && my<320)){num=14;}		if((mx>405 && mx<450) && (my>230 && my<260)){num=19}	if((mx>450 && mx<490) && (my>230 && my<260)){if(hint==0){hint=1}else{hint=0}}	if((mx>49 && mx<94) && (my>290 && my<320)){zero=zero+1}	if((mx>94 && mx<138) && (my>290 && my<320)){if(bdjj==0){bdjj=1}else{bdjj=0}}	if((mx>138 && mx<183) && (my>290 && my<320)){zero=zero-1}	}function pinbu (a,b){	var a;	var b;	if (a==0) {		pinp.volume = b;		pinp.play();		} else {		bu.volume = b;		bu.play();		}}//-----実線にもどすfunction rline(){		context.beginPath();		context.setLineDash([]);		context.closePath();}function bgcolor(){	context.fillStyle='#ffffe0'//'rgba(0, 255, 0, 0.5)'	context.fillRect(0,0,500,320);}function bgcolor_bm(){	context.fillStyle='#ffffe0'//'rgba(0, 255, 0, 0.5)'	context.fillRect(290,40,230,180);}//------マル四角を描画するfunction-----//------https://qiita.com/PG0721/items/6fb9e9c02675be832402---よりfunction fillRoundRect(context, x, y, w, h, r) {    createRoundRectPath(context, x, y, w, h, r);    context.fill();}function createRoundRectPath(context, x, y, w, h, r) {    context.beginPath();    context.moveTo(x + r, y);    context.lineTo(x + w - r, y);    context.arc(x + w - r, y + r, r, Math.PI * (3/2), 0, false);    context.lineTo(x + w, y + h - r);    context.arc(x + w - r, y + h - r, r, 0, Math.PI * (1/2), false);    context.lineTo(x + r, y + h);           context.arc(x + r, y + h - r, r, Math.PI * (1/2), Math.PI, false);    context.lineTo(x, y + r);    context.arc(x + r, y + r, r, Math.PI, Math.PI * (3/2), false);    context.closePath();}//------マル四角を描画するfunctionここまで-----//----Canvas全体をクリアするfunctionfunction cls(){	context.clearRect(0,0,canvas.width,canvas.height);}//-----ここからマウスの位置を取得するcanvas.addEventListener(E_TOUCHSTART, onTouchStart);	function onTouchStart(e) {	canvas.addEventListener(E_TOUCHMOVE, onTouchMove);	canvas.addEventListener(E_TOUCHEND, onTouchEnd);		if((mx>49 && mx<183)&&(my>260 && my<290)){stX=e.pageX;}}function onTouchMove(e) {	canvas.addEventListener(E_TOUCHMOVE, onTouchMove);	canvas.addEventListener(E_TOUCHEND, onTouchEnd);		if((mx>49 && mx<183)&&(my>260 && my<290)){edX=e.pageX;}		if((mx>49 && mx<183)&&(my>260 && my<290)){		if(edX-stX>0){zero=zero-1;}else{zero=zero+1;}	main();	}}function onTouchEnd(e) {	canvas.removeEventListener(E_TOUCHMOVE, onTouchMove);	canvas.removeEventListener(E_TOUCHEND, onTouchEnd);		mx=e.pageX;	my=e.pageY;		main();	console.log("x= "+mx+" : y= "+my)//------コンソールに座標を表示//console.log("x2= "+x2+" : y2= "+y2)}// デフォルトのイベントを禁止	document.ontouchmove = function(evt){	evt.preventDefault();	}//==========}//-------最終かっこ>>>function draw(id) { //==========